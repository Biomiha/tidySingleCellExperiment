% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidyr_methods.R
\name{unnest}
\alias{unnest}
\alias{nest}
\alias{extract}
\title{unnest}
\arguments{
\item{cols}{<\code{\link[=tidyr_tidy_select]{tidy-select}}> Columns to unnest.
If you \code{unnest()} multiple columns, parallel entries must be of
compatible sizes, i.e. they're either equal or length 1 (following the
standard tidyverse recycling rules).}

\item{names_sep}{If \code{NULL}, the default, the names will be left
as is. In \code{nest()}, inner names will come from the former outer names;
in \code{unnest()}, the new outer names will come from the inner names.

If a string, the inner and outer names will be used together. In \code{nest()},
the names of the new outer columns will be formed by pasting together the
outer and the inner column names, separated by \code{names_sep}. In \code{unnest()},
the new inner names will have the outer names (+ \code{names_sep}) automatically
stripped. This makes \code{names_sep} roughly symmetric between nesting and unnesting.}

\item{keep_empty}{See tidyr::unnest}

\item{names_repair}{See tidyr::unnest}

\item{ptype}{See tidyr::unnest}

\item{.drop}{See tidyr::unnest}

\item{.id}{tidyr::unnest}

\item{sep}{tidyr::unnest}

\item{.preserve}{See tidyr::unnest}

\item{.data}{A tbl. (See tidyr)}

\item{.names_sep}{See ?tidyr::nest}

\item{data}{A tidySingleCellExperiment object}

\item{col}{Column name or position. This is passed to
\code{\link[tidyselect:vars_pull]{tidyselect::vars_pull()}}.

This argument is passed by expression and supports
\link[rlang:nse-force]{quasiquotation} (you can unquote column
names or column positions).}

\item{into}{Names of new variables to create as character vector.
Use \code{NA} to omit the variable in the output.}

\item{regex}{a regular expression used to extract the desired values.
There should be one group (defined by \verb{()}) for each element of \code{into}.}

\item{remove}{If \code{TRUE}, remove input column from output data frame.}

\item{convert}{If \code{TRUE}, will run \code{\link[=type.convert]{type.convert()}} with
\code{as.is=TRUE} on new columns. This is useful if the component
columns are integer, numeric or logical.

NB: this will cause string \code{"NA"}s to be converted to \code{NA}s.}

\item{...}{Additional arguments passed on to methods.}
}
\value{
A tidySingleCellExperiment objector a tibble depending on input

A tidySingleCellExperiment objector a tibble depending on input

A tidySingleCellExperiment objector a tibble depending on input
}
\description{
Given a regular expression with capturing groups, \code{extract()} turns
each group into a new column. If the groups don't match, or the input
is NA, the output will be NA.
}
\examples{

library(dplyr)
pbmc_small \%>\%

    nest(data=-groups) \%>\%
    unnest(data)


library(dplyr)
pbmc_small \%>\%

    nest(data=-groups) \%>\%
    unnest(data)

pbmc_small \%>\%

    extract(groups, into="g", regex="g([0-9])", convert=TRUE)
}
\seealso{
\code{\link[=separate]{separate()}} to split up by a separator.
}
