---
title: "tidySCE - part of tidytranscriptomics"
output: github_document
always_allow_html: true
---

<!-- badges: start -->
[![Lifecycle:maturing](https://img.shields.io/badge/lifecycle-maturing-blue.svg)](https://www.tidyverse.org/lifecycle/#maturing) [![R build status](https://github.com/stemangiola/tidySCE/workflows/R-CMD-check-bioc/badge.svg)](https://github.com/stemangiola/tidySCE/actions)
<!-- badges: end -->

```{r echo=FALSE}
knitr::opts_chunk$set( fig.path = "man/figures/")
```

**Brings SingleCellExperiment to the tidyverse!** 

Website: [tidySCE](https://stemangiola.github.io/tidySCE/articles/introduction.html)

Please also have a look at 

- [tidyseurat](https://stemangiola.github.io/tidyseurat/) for tidy manipulation of Seurat objects
- [tidybulk](https://stemangiola.github.io/tidybulk/) for tidy bulk RNA-seq data analysis
- [nanny](https://github.com/stemangiola/nanny) for tidy high-level data analysis and manipulation 
- [tidygate](https://github.com/stemangiola/tidygate) for adding custom gate information to your tibble 
- [tidyHeatmap](https://stemangiola.github.io/tidyHeatmap/) for heatmaps produced with tidy principles

<!---

[![Build Status](https://travis-ci.org/stemangiola/tidySCE.svg?branch=master)](https://travis-ci.org/stemangiola/tidySCE) [![Coverage Status](https://coveralls.io/repos/github/stemangiola/tidySCE/badge.svg?branch=master)](https://coveralls.io/github/stemangiola/tidySCE?branch=master)

-->

## Introduction

tidySCE provides a bridge between Bioconductor single-cell packages and the tidyverse. It creates an invisible layer that enables viewing the
Bioconductor *SingleCellExperiment* object as a tidyverse tibble, and provides SingleCellExperiment-compatible *dplyr*, *tidyr*, *ggplot* and *plotly* functions. This allows users to get the best of both Bioconductor and tidyverse worlds.

## Functions/utilities available

SingleCellExperiment-compatible Functions | Description
------------ | -------------
`all` | After all `tidySCE` is a SingleCellExperiment object, just better

tidyverse Packages | Description
------------ | -------------
`dplyr` | All `dplyr` functions (e.g. `tidySCE::select`)
`tidyr` | All `tidyr` functions (e.g. `tidySCE::pivot_longer`)
`ggplot2` | `ggplot` (`tidySCE::ggplot`)
`plotly` | `plot_ly` (`tidySCE::plot_ly`)

Utilities | Description
------------ | -------------
`tidy` | Add `tidySCE` invisible layer over a SingleCellExperiment object
`as_tibble` | Convert cell-wise information to a `tbl_df`
`join_transcripts` | Add transcript-wise information, returns a `tbl_df`
`extract` | Extract a character column into multiple columns using regular expression groups

## Installation

From Bioconductor (under submission)

```{r, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")

BiocManager::install("tidySCE")
```

From Github

```{r, eval=FALSE}
devtools::install_github("stemangiola/tidySCE")
```


Load libraries used in this vignette.

```{r message=FALSE}
# Bioconductor single-cell packages
library(scater)
library(scran)
library(SingleR)
library(SingleCellSignalR)

# Tidyverse-compatible packages
library(dplyr)
library(ggplot2)
library(purrr)
library(tidyHeatmap)

# Both
library(tidySCE)
```

## Create `tidySCE`, the best of both worlds!

This is a *SingleCellExperiment* object but it is evaluated as a tibble. So it is compatible both with SingleCellExperiment and tidyverse. 

```{r}
pbmc_small_tidy <- tidySCE::pbmc_small %>% tidy()
```

**It looks like a tibble**

```{r}
pbmc_small_tidy
```

**But it is a SingleCellExperiment object after all**

```{r}
pbmc_small_tidy@assays
```

## Annotation polishing using tidyverse

We may have a column that contains the directory each run was taken from, such as the "file" column in `pbmc_small_tidy`.

```{r}
pbmc_small_tidy$file[1:5]
```

We may want to extract the run/sample name out of it into a separate column. `extract` can be used to convert a character column into multiple columns using regular expression groups.

```{r}
pbmc_small_polished <-
    pbmc_small_tidy %>%
    extract(file, "sample", "../data/([a-z0-9]+)/outs.+", remove=FALSE)

pbmc_small_polished %>%
    select(sample, everything())
```

## Preliminary plots

Set colours and theme for plots.

```{r}
# use colourblind-friendly colours
friendly_cols <- dittoSeq::dittoColors()

# set theme
my_theme <-
    list(
        scale_fill_manual(values=friendly_cols),
        scale_color_manual(values=friendly_cols),
        theme_bw() +
            theme(
                panel.border=element_blank(),
                axis.line=element_line(),
                panel.grid.major=element_line(size=0.2),
                panel.grid.minor=element_line(size=0.1),
                text=element_text(size=12),
                legend.position="bottom",
                aspect.ratio=1,
                strip.background=element_blank(),
                axis.title.x=element_text(margin=margin(t=10, r=10, b=10, l=10)),
                axis.title.y=element_text(margin=margin(t=10, r=10, b=10, l=10))
            )
    )
```

We can treat `pbmc_small_polished` as a tibble for plotting. 

Here we plot number of transcripts per cell.

```{r plot1}
pbmc_small_polished %>%
    tidySCE::ggplot(aes(nFeature_RNA, fill=groups)) +
    geom_histogram() +
    my_theme
```

Here we plot total transcripts per cell.

```{r plot2}
pbmc_small_polished %>%
    tidySCE::ggplot(aes(groups, nCount_RNA, fill=groups)) +
    geom_boxplot(outlier.shape=NA) +
    geom_jitter(width=0.1) +
    my_theme
```

Here we plot abundance of two transcripts for each group.

```{r}
pbmc_small_polished %>%
    join_transcripts(transcripts=c("HLA-DRA", "LYZ")) %>%
    ggplot(aes(groups, abundance_counts + 1, fill=groups)) +
    geom_boxplot(outlier.shape=NA) +
    geom_jitter(aes(size=nCount_RNA), alpha=0.5, width=0.2) +
    scale_y_log10() +
    my_theme
```

## Preprocess the dataset

We can also treat `pbmc_small_polished` as a SingleCellExperiment object and proceed with data processing with Bioconductor packages, such as *scran* and *scater*.

```{r preprocess}

# identify variable genes with scran
variable_genes <-
    pbmc_small_polished %>%
    modelGeneVar() %>%
    getTopHVGs(prop=0.1)

# perform PCA with scater
pbmc_small_pca <-
    pbmc_small_polished %>%
    runPCA(subset_row=variable_genes)

pbmc_small_pca
```

If a tidyverse-compatible package is not included in the tidySCE collection, we can use `as_tibble` to permanently convert `tidySCE` into a tibble.

```{r pc_plot}
# create pairs plot with GGally
pbmc_small_pca %>%
    as_tibble() %>%
    select(contains("PC"), everything()) %>%
    GGally::ggpairs(columns=1:5, ggplot2::aes(colour=groups)) +
    my_theme
```

## Identify clusters 

We can proceed with cluster identification with *scran*.

```{r cluster}
pbmc_small_cluster <- pbmc_small_pca

# Assigning to the 'colLabels' of the SummarizedExperiment object
colLabels(pbmc_small_cluster) <-
    pbmc_small_pca %>%
    buildSNNGraph(use.dimred="PCA") %>%
    igraph::cluster_walktrap() %$%
    membership %>%
    as.factor()

pbmc_small_cluster %>% select(label, everything())
```

And interrogate the output as if it was a regular tibble.

```{r cluster count}
pbmc_small_cluster %>%
    tidySCE::count(groups, label)
```

We can identify and visualise cluster markers combining SingleCellExperiment and tidyverse functions.

```{r}
# Identify markers
marker_genes <-
    pbmc_small_cluster %>%
    findMarkers(groups=pbmc_small_cluster$label) %>%
    as.list() %>%
    map(~ .x %>%
        head(10) %>%
        rownames()) %>%
    unlist()

# Plot heatmap
pbmc_small_cluster %>%
    join_transcripts(transcripts=marker_genes) %>%
    group_by(label) %>%
    heatmap(transcript, cell, abundance_counts, .scale="column")
```

## Reduce dimensions

We can calculate the first 3 UMAP dimensions using the SingleCellExperiment framework and *scater*. 

```{r umap}
pbmc_small_UMAP <-
    pbmc_small_cluster %>%
    runUMAP(ncomponents=3)
```

And we can plot the result in 3D using plotly.

```{r umap plot, eval=FALSE}
pbmc_small_UMAP %>%
    plot_ly(
        x=~`UMAP1`,
        y=~`UMAP2`,
        z=~`UMAP3`,
        color=~label,
        colors=friendly_cols[1:4]
    )
```

![screenshot plotly](man/figures/plotly.png)

## Cell type prediction

We can infer cell type identities using *SingleR*.

```{r eval=FALSE}
blueprint <- celldex::BlueprintEncodeData()

cell_type_df <-
    pbmc_small_UMAP@assays@data$logcounts %>%
    Matrix::Matrix(sparse=TRUE) %>%
    SingleR(
        ref=blueprint,
        labels=blueprint$label.main
    ) %>%
    as.data.frame() %>%
    as_tibble(rownames="cell") %>%
    select(cell, first.labels)
```

```{r}
pbmc_small_cell_type <-
    pbmc_small_UMAP %>%
    left_join(cell_type_df, by="cell")

pbmc_small_cell_type %>%
    tidySCE::select(cell, first.labels, everything())
```

We can easily summarise the results. For example, see how cell type classification overlaps with cluster classification.

```{r}
pbmc_small_cell_type %>%
    count(label, first.labels)
```

We can easily reshape the data for building information-rich faceted plots.

```{r}
pbmc_small_cell_type %>%

    # Reshaping
    pivot_longer(
        cols=c(label, first.labels),
        names_to="classifier", values_to="label"
    ) %>%

    # Plotting
    ggplot(aes(UMAP1, UMAP2, color=label)) +
    geom_point() +
    facet_wrap(~classifier) +
    my_theme
```

We can easily plot gene correlation per cell category, adding multi-layer annotations.

```{r}
pbmc_small_cell_type %>%

    # Add mitochondrial abundance
    mutate(mitochondrial=rnorm(n())) %>%

    # Plot correlation
    join_transcripts(transcripts=c("CST3", "LYZ"), shape="wide") %>%
    ggplot(aes(CST3 + 1, LYZ + 1, color=groups, size=mitochondrial)) +
    geom_point() +
    facet_wrap(~first.labels, scales="free") +
    scale_x_log10() +
    scale_y_log10() +
    my_theme
```

##  Nested analyses

A powerful tool we can use with tidySCE is `nest`. We can easily perform independent analyses on subsets of the dataset. First we classify cell types in lymphoid and myeloid, and then nest based on the new classification.

```{r}
pbmc_small_nested <-
    pbmc_small_cell_type %>%
    filter(first.labels != "Erythrocytes") %>%
    mutate(cell_class=if_else(`first.labels` %in% c("Macrophages", "Monocytes"), "myeloid", "lymphoid")) %>%
    nest(data=-cell_class)

pbmc_small_nested
```

Now we can independently (i) find variable features, (ii) reduce dimensions, and (iii) cluster using both tidyverse and SingleCellExperiment seamlessly.

```{r warning=FALSE}
pbmc_small_nested_reanalysed <-
    pbmc_small_nested %>%
    mutate(data=map(
        data, ~ {
            .x <- runPCA(.x, subset_row=variable_genes)

            variable_genes <-
                .x %>%
                modelGeneVar() %>%
                getTopHVGs(prop=0.3)

            colLabels(.x) <-
                .x %>%
                buildSNNGraph(use.dimred="PCA") %>%
                igraph::cluster_walktrap() %$%
                membership %>%
                as.factor()

            .x %>% runUMAP(ncomponents=3)
        }
    ))

pbmc_small_nested_reanalysed
```

Now we can unnest and plot the new classification.

```{r}
pbmc_small_nested_reanalysed %>%

    # Convert to tibble otherwise SingleCellExperiment drops reduced dimensions when unifying data sets.
    mutate(data=map(data, ~ .x %>% as_tibble())) %>%
    unnest(data) %>%

    # Define unique clusters
    unite("cluster", c(cell_class, label), remove=FALSE) %>%

    # Plotting
    ggplot(aes(UMAP1, UMAP2, color=cluster)) +
    geom_point() +
    facet_wrap(~cell_class) +
    my_theme
```

We can perform a large number of functional analyses on data subsets. For example, we can identify intra-sample cell-cell interactions, and then compare whether interactions are stronger or weaker across conditions. In this small dataset we have just two samples (one for each condition) but you can imagine how you can use tidyverse on the output to perform t-tests and visualisation.

```{r, eval=FALSE}
pbmc_small_nested_interactions <-
    pbmc_small_nested_reanalysed %>%

    # Unnest based on cell category
    unnest(data) %>%

    # Create unambiguous clusters
    mutate(integrated_clusters=first.labels %>% as.factor() %>% as.integer()) %>%

    # Nest based on sample
    tidySCE::nest(data=-sample) %>%
    tidySCE::mutate(interactions=map(data, ~ {

        # Produce variables. Yuck!
        cluster <- .x@colData$integrated_clusters
        data <- data.frame(.x@assays@data %>% as.list() %>% .[[1]] %>% as.matrix())

        # Ligand/Receptor analysis using SingleCellSignalR
        data %>%
            cell_signaling(genes=rownames(data), cluster=cluster) %>%
            inter_network(data=data, signal=., genes=rownames(data), cluster=cluster) %$%
            `individual-networks` %>%
            map_dfr(~ bind_rows(as_tibble(.x)))
    }))

pbmc_small_nested_interactions %>%
    select(-data) %>%
    unnest(interactions)
```

If the data set was not so small, and interactions could be identified, you would see something as below.

```{r}
tidySCE::pbmc_small_nested_interactions
```

# Session Info

```{r}
sessionInfo()
```